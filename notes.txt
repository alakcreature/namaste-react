Here React.createElement() is just a object which will be turned to html tag by the render method by creating a tree in the dom.
ReactElement(Object) => HTML(Browser Understands)
Whenever we pass root.render, the contents in div.#root will be replaced by that.
We can use react in uor existing project because it wil only affect only the root html tag. That's why its a library not a framework.

Bundler: It packages our app properly so that it could be shipped to production such as webpack, parcel or vite.

dependencies & dev-dependencies

package-lock.json: It keeps the track of all the versions of all dependencies.

To install a package we use 'npm' and to use any package we use 'npx'.

- if we want to remove console.log(*) calls from our production build files, use babel-plugin-transform-remove-console package


- JSX: React came up with a philosophy that we have to update html using javascript. It is HTML like syntax but not HTML syntax.





Ep-5

- one way data binding: that's why input tag is controlled by react and we must use usetstate to handle it properly. one reason for this is to let other component
  & the same component know when input value is changing.
- two way binding: using usestate 
- Hooks are normal function
- useState hook is used to create a local state variable
- Why usestate is used?: to provide react about every local state variable so that it knows where to update the dom.





EP-6

- conditional rendering
- diff algorithm is a part of core react.
- updating the dom is done by react dom 



EP - 7

- Never create a new component inside a component because every time AppLayout renders then a component will be created	every time
- Never write usestate & useeffect inside if else block or inside for loop
- React router dom & configured createBrowserRouter
- Dynamic Router




EP - 8
-nested routes = parentPath/{path} => localhost:1234/about/profile  = path:"profile" 
- class based components
  - We cannot render anything without render method
  - Render method return some jsx
  - React will attach all the props to class (this)
  - why do we call super in class based components?
  - why can't we make useeffect callback function async?
  - constructor is a place where we initialization of state variables takes place
  - We do not mutate state directly, because react will have to know when to re-render the app. It keeps UI in sync.
  - Lifecycle Methods
    - constructor
    - render
    - componentDidMount
    - componentDidUpdate
    - componentWillUnmount
- React first renders all the child components, then start commit phase for all child components (while updating in the actual dom)
  - All constructor and render methods are part of render phase & componentDidMount, componentDidUpdate, componentWillUnmount are a part of commit phase in which
    actual DOM gets updated.
- When we use async in front of componentDidMount, then it will delay the componentDidMount to run and it will go ahead with Parent - componentDidMount to run. 
- Whenever we change the page via route, then we need to clear somethings in that component
